So, we are we are going to start talking about the Raspberry Pi,.
what is the general sense of this of this platform,.
and some additional topics about what is an embedded system.
different strategies to develop things.
Okay, broadly you know that this project was starting in 2006 Okay.
In UK, okay because one of the motivation of this project was the idea of that young people in general don't have enough technological skills related to the use of computers okay.
So, the idea of the British government was to launch something like a very cheap platform to help young people even in the in the lower levels of the schools to develop programming application okay to develop their stem the typical abilities and skills in Mathematics, Physics and these kinds of things.
So, they just started going on this platform with the idea of in principle to use this only in the British schools, but, quickly the platform started to develop a very of course, it's very cheap solution.
And there are a lot of people interested in in general.
in the development of embedded application electronic software solution using the Raspberry Pi, okay.
If you have a look to the to the slide, you will see how at the beginning of the project, they immediately started to to sell a lot of products, and when there goes approximately the number of units that the red Raspberry Pi, the foundation of the Raspberry Pi has produced it sold is around 40 million.
So, what is of course is an impressive number, okay.
It's quite important also to know that finally, I think two years or three years ago, they decided to move to move the production of Raspberry Pi to Wales okay, and this is something that is generating an interesting technological area in this part of the of the British, of the British country.
So, if we have a look to the different models, we can discover that this product has a continuous evolution during the different period of times, okay, we started at the beginning with a Raspberry Pi version one model B. And nowadays we are using models like Raspberry Pi model four, sorry Raspberry Pi four model.
B or even more electronic and embedded systems solutions oriented like the Raspberry Pi computer module or the Raspberry Pi Zero, okay.
In this course, we are going to use a Raspberry Pi, version three model B plus, okay.
This is the version that we have here and is more or less all the hardware is more or less quite similar in terms of performance in terms of peripherals, in terms of possibilities, okay.
The only difference is is the final performance of the processor,.
the amount of DDR memory that you have available.
and these kind of things, but the idea of the platform is more or less the same for all the different versions, okay.
Which are the main elements that we have in this platform?
The first important point is to mention that we have something that.
the manufacturer called system on chip.
is the manufacturer is Broadcom.
And they are integrated in in the same chip, a GPU, this is a graphical processor unit and a quad core ARM processor.
Okay, so it's a very powerful solution.
It's not mentioned in this in this figure,.
but they also have in the chip, a DSP a digital signal processor.
but there's something that Broadcom is not giving information to the developers of how to use this data centre processors unless that you contact with them and sign an agreement to develop solutions.
So for us, the important is that we have in a very cheap solution something that is very affordable,.
we have a quad core solution to develop embedded platform application.
that we will see later what is the idea.
Okay connected to today's chip,.
Broadcom provide also a DDR memory one gigabyte or even two gigabytes of DDR memory to store the typical data and code.
for for your applications in the operating system solution or departmental solution.
We have a specific chip providing the USB ports and the FMF connection.
This is a different chip that is connected in the PCB of this electronic system.
In the Raspberry Pi version three, we have a Wi Fi element in the reading all the hardwired that you need to deploy and use the Wi Fi.
And of course, we have here different other peripherals that are very useful to develop applications.
Of course, we have this connection to connect your graphical output, we have the option to connect a camera, we have an audio output,.
 we have a micro SD connector to insert the SD card that we will use to boot our operating system solution.
And finally, we have here a connector, a 40 pins connector in a deal format to connect different GPIO elements I squared C chips, SPI element serial line devices.
We will use that in our lab okay to connect peripherals and connect sensors to implement application, okay.
All these elements are available in this platform that I showed you before okay, this platform the Raspberry Pi three model b plus, okay.
Okay, please if you have questions, no problem, raise your hand and ask.
So, what we have here?
More information.
This system on chip, okay.
So, with CPU, DSP and GPU and we have different models from Raspberry Pi one Raspberry Pi,.
four different models from Broadcom, this American manufacturer USA manufacturer.
You have here the versions of the of the processor that we have in the different versions of the Raspberry Pi.
for our specific Raspberry Pi three, we have a quad core ARM solution, okay, running on 1.2 gigahertz, okay with an ARM version eight cores, okay.
And additionally, we have this GPU is a graphical processing unit that is able to run different libraries or binaries that are provided also by Broadcom to accelerate typical video applications.
And this is something that is provided by Broadcom.
This is not open source, okay?
But it's something that you can use in your application.
And as I told you before, the system on chip also includes a DSP that is undocumented unless that you contact with Broadcom.
In that case, if you pay before of course, you get the information to develop.
One important thing is that the memory the ROM memory, the DDR memory is physically installed in top of the of the chip, okay, on top of the processor and for the Raspberry Pi three we have one gigabyte of RAM memory, okay one gigabyte of RAM memory, okay.
The DSI interfaces typically are working at 10 or 100 megabit per second okay is not able to work out one gigasample per second.
And the chip that is provided in the this Ethernet connectivity is also giving you the USB connectivity, okay.
So we have plenty of USB ports to connect keyboards, to connect the mouse or to connect other USB printers.
We need a simple power supply of five volts to boot the Raspberry Pi Okay.
Be careful with this, because if you connect any specific USB or five volts and you are not providing enough current,.
you will see in the bot a lot of messages messages, giving you feedback about the power supply is not stable, you need to give, you need to provide a good power supplier of five volts or with at least two ampers or something like that, something similar, to get a Raspberry Pi running at the maximum performance.
And additionally, we have different interfaces to connect a display, high resolution displays, or to connect your typical monitor screens to display your high high resolution graphics, okay.
So it's a computer in a very simple and a smaller form factor, very cheap for the development of application.
More things that we have available, we have the option to use a very old interface to connect a video output.
Of course, we have here an audio connection,.
the use of an SD card that's crucial for us.
because here we are going to provide the operating system and the programs to to develop our solutions.
 and this connector this 40 pin connectors in a double row of 20 pins, each one with serialized I squared C interface SBI interface.
So, here basically we are going to use these interfaces,.
the serial line and the I two C interface.
We are going to connect here the accelerometer and the color sensor and we are going to connect here interface and USB to to the serial line interface.
to connect these to a computer to see how the system is configured and to run programs and applications, and other things that are available to connect order peripherals.
So, this is the Raspberry Pi with an identification of the different elements.
And this is the connection that we have in this connector in this 40 pin connector, okay.
And this is something that will be very familiar for you because you will be connecting the different cables to interface the accelerometer and color sensor, okay.
So this is the hardware.
So here's my computer or if you want a very powerful microcontroller, if we want to call this microcontroller.
I don't like to call this microcontroller because we have four cores with a very complex solution.
But from the point of view of that we have there the peripherals we have the CPU, in principle is a very powerful microcontroller, okay.
So, the point is, which are the steps that I need to follow to develop application here are probably the first step is to decide which kind of developments we will we want to do.
Let me explain.
Typically 99% of applications are going to use an operating system,.
this operating system typically is Linux and embedded Linux solution, okay?
We have the option of use the Linus provided by the Raspberry Pi foundation,.
they call Raspbian is very well documented how to install this, okay.
You don't need a hard disc, you only need an SD card to install the operating system.
Typically eight gigabytes is enough.
I recommend you that you use a high speed SD card, okay, because the performance of the system depends on the performance SD card.
And you have here all the tools that you need to develop applications.
Okay, be careful with this.
Because this means that we can combine, link and debug programs in the Raspberry Pi.
This is not a standard way that we that we typically follow.
when we are doing application with microcontrollers because we use a computer.
In one computer we have the compiler, we have the linker, we have the libraries.
We have the debug tools, and what we typically do is to download the code and more or less try to implement a remote debugging of that, okay?
But if we use the Raspberry Pi with the operating system with Raspbian the Raspbian provide all the compilers, linkers, debuggers, the typical utilities okay.
So, you can develop your applications there and you can run the application there, okay.
And this is the thing that we are going to cover in the first block of the course in the unit one, okay?
We will develop a C application that is compiled in the Raspberry Pi and is debug in the Raspberry Pi okay.
This is not a professional approach, this is a more or less a getting started approach, okay, not the professional one, okay.
For example, trying to provide solutions for for IoT application, Ubuntu is providing a specific version of Linux or Raspberry Pi for the development of IoT applications.
Okay, so, you having one SD card, all the tools to deploy IoT applications without the need of use of external computers, okay?
I repeat this will not be our approach because we will use another different approach that is more professional.
The other option, probably 100% of obligation is used bare metal.
So this means I forgot to use operating system.
I don't want to use a commercial solution or, or open source solution, I prefer to develop my own my own, and no problem, I can program directly with information.
using a C compiler and that's all.
And you can imagine that this is not simple.
And I I think it's preferable to avoid this way of doing the things.
because you are not reusing code and is quite difficult okay.
But if you have a look at different solutions using the internet, Google and these things, you will see that is something that some people is trying to do.
Some more tools.
Independently if we are developing bare metal solutions or solutions using Linux, we are going to use compilers, linkers on debuggers for ARM processors, okay.
And we are going mainly programming C and C++, you will see that there are a lot of people programming for the Raspberry Pi using Python.
But this is for more or less for academic solutions.
Or for very, very more or less simple solution not for professional applications.
So, this is a first approach of different options to program.
and to develop application using the Raspberry Pi.
Do you have questions?
Are you understanding me?
Yeah, sure.
Think about this, okay.
Because I think that we will have time to discuss about this point later.
Okay, so the main of the course, the name of the course is.
development of embedded applications, embedded solutions using Raspberry Pi.
So now we know what what is a Raspberry Pi.
The other concept is, what is an embedded system?
Is anybody ready to explain me in one minute, what is an embedded system?
Or what's your opinion of what an embedded system is?
Or you have an idea of what's this?
Try to speak loader, please.
So basically, the embedded systems are pieces of code, that are implemented in electronic stuff like, I don't know, TVs or refrigerators.
but only pieces of code?
Not only, hardware.
that's the point the scaling of the XX is smaller rather than the software that we use in our, Okay, good.
And the other message is that it's a specific application.
So we are building a specific hardware solution, with a specific software application solving on a specific problem, this is an embedded platform.
And this is something that typically we are not updating, we are not changing everyday.
An embedded solution typically is not going to reinstall the software remotely or these kinds of things.
Okay, something that is doing a specific job that the designer has decidedand of course, you can upgrade application and you can change the XX of course,.
but this is something is not on mobile phones in the sense that we are changing everyday application and changing everyday the different software solution that we have.
So, considering this an embedded system is something that is specialized in doing something special okay.
So, generally is a computing system, okay, with a specific software application and.
these hardware is connected with an environment because we are measuring different physical variables, temperature, humidity, how our motor is doing things or how different sensors are giving me for measures.
An idea is that we are going to develop a software application that is running in this hardware.
Typically, this embedded system is part of of another more complex electronic system okay.
And typically, we are providing solutions that are given an answer in real time.
So, I need to generate an answer or a response to a specific event in a specific time.
So, an specific time.
And as I told you before, this is something that generally speaking is part of another complex system, okay.
So, for the point of view of example of applications, a smartphone is an example of an embedded  system with this assumption that in our mobile phone, we are updating the software every day, okay, and this is something that is not very normal in an embedded platform.
It's more of watches, printers, gaming consoles, wireless routers, and in general, all the applications that we see we see today for IoT are in general embedded system oriented applications, okay.
So, at the end of the course, we are going to develop.
an embedded system using the Raspberry Pi with my specific Linux distribution connecting different one accelerometer and one colour sensor sensor.
And we are going to transmit the information to another computer to make decisions.
So, okay, so, if we have a look to the hardware that we have in an embedded system,.
this is something that probably is quite familiar for you, because you have some experienc.
using microprocessors, microcontrollers or even more powerful systems.
So we have a microprocessor, an element that is able to execute a bit of a piece of code writing in a specific language that is specified by the manufacturer.
We have a program memory and a data memory.
So this means that we we have two different memories to store the code and data.
And we have here different peripherals and interfaces to exchange information with other external devices using digital input output using analogue input output, using timers or using all the peripherals like SPI, I squared, C, etcetera.
Okay, generally, when you are developing things with microprocessors, the microprocessor is a single core processor.
Okay, the trend nowadays is that some microcontrollers, some manufacturers like STM is moving to dual core processors.
But in general, we work with a single processor.
We have different memory blocks, different peripherals.
And we use all of these things for the implementation of general purpose application, measure analogue signals, interfaces, these digital elements, etcetera.
Typically we implement these using microcontrollers.
That's a typical solution.
In our case, we are going to change this by a Raspberry Pi.
So in the Raspberry Pi, we will have an embedded solution to this one.
From the technical point of view, which are the options that we have nowadays.
to develop embedded solution okay?
So, please pay attention to this column first.
And here we have here different technologies to do things,.
to implement embedded systems and we have here different variables to be considered: cost of design, cost of productions, how to upgrade the hardware, the size, the weight, the power and the performance in general the performance of the system.
And we have different technologies.
This catalogic so, I developed a specific application using the old method method to develop things, using specific chips.
Of course, this is only interesting when we have a high budget and we are selling a lot of number of elements.
One of the typical solution in the market is the use of Field Programmable Gateaways and XX devices.
Mcroprocessor plus memory plus peripherals.
This probably the experience that you have.
The people that have studying in this school has experience with these solutions okay.
the use of FPGAs or PLDs of high density.
PLDs, okaymicroprocessor and memory plus peripherals, okay installing a specific microcontroller and finally, an embedded PC okay.
So, more or less the Raspberry Pi is moving in this segment, okay.
Okay, they are easy to upgrade, because typically the theme that we are changing is the software of the application okay.
So, have a look at the content of of this slide later, because again, this is a summary of the different technologies that we have.
Which are the benefit of develop an embedded systems solution?
The first one is that we have a good performance, a good efficiency.
This means that for instance in the case of Raspberry Pi, if we use a specific embedded Linux solution.
we will reduce the size of application and we will improve the execution time of the operating system for instance okay.
So, in that in that sense is more powerful, the performance is better that if we use more or less a classical solution.
using a standard our operating system with a classical configuration, okay?
Another benefit?
A lower cost.
We are using a more computer with a very specific and simple software solution and in that sense, this is something that is reducing the manufacturing cost okay.
If we compare these with other more difficult solutions.
The option of have more more features in terms of adding more things to the system is something that depends on the solution could be not possible okay.
But depends on the specific implementation that we have in the system.
In general, the Raspberry Pi does something that is easy to up because we have different standard interfaces.
So, adding more functionalities to the system.
is something that is simple simple to do.
And better dependability.
So what means this?
What means this sorry?
If we think in terms in terms of failure, in the integrity of the system, in an embedded system, this is something that is very very wrong in terms that we have generally hardware that is very well known and the software in general is very simple, okay.
If you compare that for instance with a solution that is using a higher power system or a computer system with a very complicated operating system and a very complicated software applications, then the debugging of the system to obtain a system that is stable and is free of failures is more difficult.
So in an embedded system is something that is you can repeat, you can control and in general we can say that is something that is free, in general of failure,.
okay, considering that the hardware and the software is correctly are correctly designed, okay.
Typical functions of an embedded systems that you can develop, for example, with a Raspberry Pi.
control systems, because it's quite easy to measure different physical variables and depending on the values that you get, you can activate different actuator.
So, in that sense is quite easy.
to develop closed loop control systems.
Quite simple to develop applications that are generated under specific sequence of operation because as we are programming, we can decide the condition of our system depending on the different phases of our specific solution.
Signal processing, you can acquire your signals from your analogue element, you can use these POWER processors that you have there to run a specific software algorithms, even artificial intelligence algorithms, so you can implement powerful signal processing applications.
And finally, communication and networking as soon as we have FML and wireless,.
it's quite easy to get data from external sensors and send information to the to the cloud or to other microcontrollers or to other computers using the Wi Fi or Ethernet or serial lines that we have available in the platform.
So, in that sense is an interesting approach for the development of applications.
Some constraints, of course, the cost.
This is approved generally is very competitive, of course, in the case that we use more or less commercial platforms.
like the Raspberry Pi,.
quite quite cheap to develop things.
So, the size and weight of course is very well controlled, because we are talking about small problems.
So the weight is not is not a problem in general depending on the application the power could be a problem, but in general.
this is a low power consumption hardware this is not a desktop computer, this is not a laptop, this is on a small embedded system.
And if we play with with the use of sleep mode and reduction of the energy we can extend the battery capacity a lot of time and in principle,.
there is no problem with adapting our hardware to a normal environment.
, the typical environment of the industry working with the typical temperatures, okay.
Of course, depending on these constraints on your specific application.
, you have to balance what is the best solution that you have to follow.
You have microcontrollers,.
you know very well probably that solution.
You have programming this that those microcontrollers using C or C++, okay.
In general we use C and C++ because the compiler is providing us a very good solution.
In the past it was quite common to develop things in Java for a specific solution,.
but the market now is in C C++ around 90 99 95% of applications are developing C or C++ in C++ in the embedded market.
If you have performance issues, you can move to assembly but this is something that is very very strange is not typical.
So, in the case of the solution body metal embedded system, typically the parameter application is used for very low low power consumption solutions.
And it's the typical solution when you when you need to do something that is quite quite simple.
As soon as you increase the complexity of the system,.
you move to a use of the operating system and the market now has two different approaches: the use of embedded system solutions.
is the approach that we are going to use here.
or the use of a specific real time operating system uses for instance for for the case of ARM, the use of CNCS head-toes solutions using FDX or using free or RDOS okay.
But we are going to work with this option: a customize link, an embedded link.
So, embedded software?
What is embedded software?
It's a software that is running in an embedded platform a hardware platform.
In principle is a software that is oriented to development to the development of a specific application to control a machine or device.
Something that is not general purpose, something very specialized with some limit memory requirements.
So, we are not consuming a big amount of memory,.
sometimes this doesn't require an operating system or sometimes depends on the application,.
subject to timing constraints because we probably will need to meet some real time limits or some or some real time goals, okay.
And in general something that is not requiring the use of a person in front of the system to make a decision because the decisions are are made by the following XX with the help of this XX.
What is the typical approach to develop these embedded software solutions?
We can start playing with the idea of developing a specific solution for my specific hardware okay, but in that case, you need to have a very good knowledge of the hardware.
So, that's difficult and typically what we try to do is to apply any kind of any kind of abstraction sorry to simplify the software development okay.
So, in general, we are going to use the hardware trying to avoid the low level details,.
okay, you will see this very, very, in a very straightforward way.
when we start using the I2C interface in Linux.
because you will see that this is a very good way.
to use the interface with the hardware.
with a very good level of abstraction Okay, avoiding the use of problems.
The responsiveness of the system, okay something that we can control because we don't have very huge number of software layers.
So, as soon as we are moving our application very close to the hardware, the triggers can be detected immediately and we can respond in a very agile way reducing the latency of the system.
We can manage the concurrency that this is something that is difficult to implement in a microcontroller unless that you have an operating system.
So, in Linux,.
this is something that is very simple, very simple,.
because as we have the operating system, we can launch different threads in parallel.
And we can manage different different physical events that are more or less simultaneous.
using this ability of the operating system.
The reliability that's a problem because if we have issues with the gold or with the hardware, we can generate catastrophic problems to the installation.
So, the reliability is a problem.
But again as we are reducing the software layers and we are using a very well known hardware.
we are simplifying their estimation of these values and we are reducing the probability of failure and with that, we are improving the reliability of the system.
And the efficiency.
Of course, if we are using an SD card instead of a hard disc,.
if we are using this powerful processor that we have in the RBI where we are managing the different power modes,.
we are reducing the consumption of energy and of course we are improving the efficiency of the system okay, difficult to see now.
This is something that you typically you have to discuss.
when you are developing a specific application.
So we have the hardware, we have the software we have tools to develop applications.
Typically a C compiler, linker and a debugger.
The debugger must be connected to the hardware, okay, and the question here in this course is: okay, how we are going to debug applications here with a Raspberry Pi?
The interfaces that typically we have in our embedded platform with a microcontroller are specific hardware interfaces provided by the manufacturer.
For instance, some of you have experience using the SD microcontrollers and the recently specific interface to interface the debug solution okay.
But in the case of the Raspberry Pi, we are going to use the Ethernet interface and the serial line interface to provide the debugging, okay.
So, the strategy to develop and develop solutions will be a little bit different.
of the solution use in microcontrollers.
Okay, we will talk about this in the future, okay.
So, if you mix all this information and you shake your brain, okay.
Now, what I want to do is an exercise of make some decisions about what are the tools that we are going to use here, okay.
So, now, we have a Raspberry Pi with an ARM multi core platform integrated in the Broadcom chip, we have an I2C interface that we will use to connect two sensors, we are going to develop an NVIDIA Linux operating systems bared solutions to run our applications.
So, with that, we are going to build more or less than a standard embedded platform with a standard embedded software solution that is the embedded Linux.
Okay, a customized Linux for my application and in top of that, we will develop application in C or C++ okay using the GNU tools, compiler, linker and the GDB debugger we will use Ethernet as an integral line to develop the applications okay.
And finally, we will be doing developments using Eclipse to compile our applications leave the application and debug remotely in the Raspberry Pi that will be our approach, okay.
Completely different of the things that you are studying.
micro processors or micro processor system base.
that you are using a very specific hardware with a very specific tool provided by the manufacturer that is allowing you to debug a very simple solution.
Here the advantage is that we have the Linux kernel and with that I have TCP IP communications using cable or wireless interfaces, I have access to SPI, I2C and other serial lines and typical protocols okay.
So, for me is quite straightforward to develop applications.
in this point and this is something that the manufacturers are doing in the market okay.
use the Linux installed in a specific hardware platform to develop application.
Are you understanding  me please?
yes yes?
Questions?
And this is one approach okay.
Probably if we discuss in one week, you can do it, you will find different approaches to do it okay.
But this is one approach that by the way is very common in the industry.
Okay?
No questions? No?
No questions? Okay.
So market trends.
So, what means these?
So, what is the themes now the manufacturers are doing now, okay.
I want to show you this monster okay.
This is a monster of the technology.
It this is what ceilings called called calls the AC AP pick up solutions.
And this monster if you allow me the use of this terminology,.
this complex platform has: here you can see that a dual cord Cortex A processor, okay.
Or something similar to the processor that you have in a in a mobile phone.
Okay, a Cortex air is a specific real time processor is not a Cortex M, you have follow the microprocessor course here at UPM you know and a Cortex M platform, this is a Cortex air solution oriented to real time application.
Here we have a very complex logic, XX logic, equivalent to a very powerful API.
Here we have a specific hardware to run silence codes, the artificial intelligence engines okay.
Subfield devoted to implement algorithms to run neural network.
Okay, that is quite common today.
And this is typically they are integrating 60, 64.
Depends on the on the model of the chip that you that you buy.
And this kind of this kind of engine.
And additionally, a specific DSP engines that are more oriented to signal processing to audio application and video application.
Okay, so, artificial intelligence cores, audio and video processing engines, programmable hardware to deploy your specific applications.
The typical application to run an embedded Linux platform on an Android solution, but typically an embedded platform here.
A Cortex solution running and CNCs.
So another kind of embedded system solution more oriented to real time real real time applications.
And all these elements are connected to something.
that they call network on chip.
Okay, so the network is on, in this case, in the chip inside the chip.
Okay, so when you programme all these elements, and you move the information from one site to another site, and you implement very complex solutions.
And here, in the bottom part of this video, you have the different interfaces and the different memory elements.
And you can see here that the technology is moving to 40 gigabyte Ethernet connections, 100 gigabyte Ethernet connection, 400 gigabyte Ethernet connections,.
this is quite expensive, by the way.
Okay, we're talking about 1000 euros per component.
So if you want you can buy one of these, okay?
Quite expensive, but these are top of the technology, but I want to call your attention that this is very complex,.
 by by the solution provided by the manufacturer is running here, in the embedded Linux.
Okay, because the embedded Linux is the element that is controlling all the application.
Okay, more or less, the heart of the system.
So it's a very, very interesting platform for the future, because this is something that is available in the market.
I think that since the middle of 2020.
Okay, so it's a very new, very new platform.
Something something equivalent from the other manufacturer of these kinds of technologies Intel is providing it's not as complex as the other solution.
because they are only integrating the BGA part, and the processor part and some high speed technologies interfaces.
But in the end is the same idea.
We have a multi core ARM processor, running an embedded solution.
And if you want to play with this hardware to develop application,.
the first thing that you need to know is how to develop an embedded Linux platform.
You'll see the instruction there and you'll see what's this?
And you see that.
And what's the way to program the application here?
To use C and C++ using Eclipse, and you develop your applications and you download your applications to that to these embedded Linux solution that is right there, okay.
And this is something that in the market is quite interesting, it's a very hot topic.
And if you have a look to the company that are trying to hire people, you will see that this is something that is a topic that the companies are very, very interested in new engineers managing this technology.
Okay, So, with this in mind, and after this brainstorming of ideas, I would like that you think in the following questions, okay.
And try to search for an answer of these questions that I would like to discuss with you next week.
Okay, so, the idea is a have a look, search for the information using the internet using Google or other tools that you consider interesting, and have a look to find details additional details and discuss about what means this, okay.
So, the Raspberry Pi three, what is the architecture that we have there?
Okay, there's an ARM processor but have a look to that, if this is a 32 bit or 64 bit core, what means bar meta programming?
And in this sense, what software tools are required to implement this bare metal programming?
Have a look to this and you will and you will find, you will see very, very freaky solutions.
What are the advantages and this is the important point what are the advantages and disadvantages.
of using bare metal programming versus operating system programming?
This is something that I I that we want that you think about it because is the origin of this course, okay.
So, we are not using the embedded Linux solution by itself,.
we are using this because we consider that this is something very flexible .
to develop solutions in the not only in the electronic market, but also in general embedded platform solutions, okay.
So, think about it and give us your opinion about this.
More questions, what are typical what are the typical compiler and leaker that you using a Linux operating system?
What are the tools used to compile and link a program?
Options, but you have to do this: review the concept of compiler and link.
because probably if I asked you about this I will find some misunderstandings about this, okay?
And it's something that you are going to use a lot during this course.
What means compile?
What means link?
And this different compiler and this differently link.
What is a library?
Have you ever used before a library to programme something?
In that case in that case which are the extensions that these domes libraries have?
What is the purpose of the Linus make command?
This will be something magic that we are we are going to use along the course, okay?
How to use to use the main tools to compile to link and to deploy applications?
And in that sense, a make is using a make file, what is a make file?
And what is the purpose of that?
You know all of these concepts are very familiar for you because you have been developing applications for microcontrollers.
So, the idea is to more or less to put the information in parallel and we are working with a different solution okay.
What means user space and kernel space in Linux?
Of course, this is new for you.
Because kernels means develop things inside the operating system and user space means to develop application in a user level.
Okay, have a look to that.
What is a GPU?
I mentioned before the graphic processor unit.
You know that this is very common today because I don't know if anybody of you.
is developing mining applications to earn money with bitcoins probably yes.
But this is something that is very common.
So is this a training technology that you find system on chip with GPUs implementing neural network solutions for graphic algorithms and in general is a compute unit okay.
In that sense, what are the main advantages of using GPU?
Advantages and of course disadvantages.
What is the typical programming method to develop application with GPUs?
Okay, so think about this because you will have to submit the questions to Moodle.
Okay, and we'll open up a chat with a very simple opinion from you about this.
And work that you need to follow after this.
In Moodle, you have a document that is called Getting started with a Raspberry Pi document.
It's a wonderful , it's a PDF document, sorry.
Read and study the content.
Download and install Raspbian on your Raspberry Pi,.
later we are going to give you the material, okay?
The only material additional material that you need is an SD card.
So you need to download the Raspbian operating system from the internet.
Okay, put the image on the SD card and boot the Raspberry Pi.
Okay, please check the information that will be available on the Moodle site about the work that we are going to complete during the next week.
It's a very simple program, but I need that more or less you understand all the steps that we are going to follow.
Do you have questions?
Sure, no questions?
Everything is clear?
You are not telling the truth.
For sure.
No questions?
Remember, you need to buy an SD card.
Okay, and my recommendation is that at least buy a couple of SD cards because we are going to use one for the Raspbian and the other one for the Raspberry Pi.
Sorry for the embedded Linus for the Raspberry Pi.
And sometime probably you will need to check that your hardware is working well,.
 and one of the option is to use the Raspbian to boot and verify that your Raspberry Pi's working one.
This is a recommendation, if you don't want, no problem, okay?
For the embedded Linus solution, if you have an old SD card is enough.
So if you recycle one of the old SD cards of 52 megabytes or 64 megabytes that nowadays are useless for a mobile phone.
That's a great solution for the embedded platform.
But for the Raspbian, no, I prefer that you use, of course it's much bigger SD card and you need at least eight gigabytes.
And if you use our high speed SD card is fantastic because you will see that the Raspberry Pi is running very very well.
Okay and the performance is very, very good.
Okay, so we have 10 minutes of break and we will do the last presentation today about today.
about the use of githubs,.
okay, and later we will give you the material okay.
So thank you!
2nd SessionOkay, so must fortunately last presentation today, okay, and sorry for this amount of information, but is the first day we have to start talking about different topics and it's the first day, so we have to come to use all the time available.
So the idea is that during the course, okay.
I encourage you to use the git, okay?
The reason is simple.
Traditionally, you most part of our students typically develop applications, doing different kinds of programming techniques.
And people just do a copy on a copy and a copy and a compressed file compressed file and it's is impossible to track the evolution of the code, okay, and it's impossible to solve problems, as soon as you are developing a complex application, okay?
So the idea is, is that you try to use an external tool to.
to have your code control it, in this case, git, okay.
And this will be very useful for two reasons.
First for you, because as soon as you are doing changes, if you if these changes are, say are safe in your system, you can check the evolution of your code.
But it's very useful for me to verify the different steps that you are doing.
And if you report a problem, I can find a solution in a more simple way.
that you deliver me a folder with a lot of code, okay?
Probably some of you don't have experience using this.
So the idea to today is to do a short presentation of this with the aim of use this during the course, the step by step and I hope that at the end of the course,.
you we will be able to do a simple management of this only for control your code.
How many of you have experience using git? two?
So, 20% more or less.
So, what's, what's a git?
This is a version control system.
So, the idea basically is to control source code and to control the evolution, the changes that we have in the code, okay, this is one of the objectives.
The other objective is that this allows to work in parallel in the implementation of XX.
So, this means that if we are working in a couple and we are developing a project together,.
we can modify the source code of our applications and we can integrate the application in a very simple way.
That's the idea, avoiding conflicts and avoiding problems, and easy, this is why these collaborative tools are very frequent today in the programming or in general in software, developing techniques.
Typically, typically is a scale that is required by companies independently if you are working in software project or in hardware projects, okay?
So, it is something that is today's mandatory, okay.
So, what is the idea?
The idea is that we can register the evolution of of the source code in general generally, we are working with code that is written in text files, so, we can verify the syntax and the evolution of the code, okay.
We can work with different evolutions or different version of this code.
The idea is that we can develop my basic application and as soon as I'm progressing in the development of application, I can generate different releases of my software for my clients or for my other users, etc.
We will see that in detail in the next lecture, in the next week.
Tools available.
Forget this one because it's very old,.
typically in the industry people is working now with SVM.
It's a very old tool but is currently in use in some labs and some companies but most of people is working with git.
For instance, when we start using build route, we will see that Build Route basically is connecting to different GitHub Git labs or in general git repositories.
And it's downloading copies of that code to a local repository.
It's essentially the same that that you do when you go to a website and you download code locally, okay.
This is the tool, that we have to send as a reference for the course.
Who are who was the developer of these tools?
This crazy guy Torvalds Linus, I probably you know him, okay.
Very famous, it's a poor guy, okay, with no money with no resources, but he's the head of the development of all the work related with the Linux XX, okay?
Of course, git is open source, and it's available for a lot of platform Windows, Linux, etc Okay.
So, in your computer in the Windows the station that you have here you have in this lab, you have the Git client is installed on that Windows okay?
I mean the Linux virtual machine, Ubuntu Linux virtual machine that you will be using in the following weeks, the Git will be installed there, okay, you have to install it, okay.
So, you can develop application in different languages.
So, we are we are going to work with C or C++ for our development.
and you can have multiple people working in the project developing specific parts of the project and you can in any moment, check a version of the status of the project, compiling the complete project and verify if the project is working or not.
We will see later.
Where the repositories will be located?
We will use typically we have three options, Bitbucket, GitLab, GitHub, and others.
Probably some of you are using GitHub or GitLab or even GitHub, BitBucket.
I propose you the use of Bitbucket, okay, the free version of Bitbucket is an option,.
don't worry if you use another one, but the idea is that you create a repository here and you share the repository with my colleague Miguel ï¿½?ngel and myself, okay.
And in that way we can check the evolution of your project.
Again select what tool you prefer to implement the solution.
Okay, concepts.
We sometimes we have something that we call repository, okay.
But this is something that is located somewhere, okay, typically, in the cloud, containing the different files of your project.
And typically, what we are going to store there are is generally the source code, not the binary, okay, but source code and all the additional files that you need to build your application.
Okay, and the instructions to install, to compile, to link and to deploy your application.
That's the idea. Okay.
We will have the options to check or to verify the different versions that we have a one file, okay, and you will see how to track the evolution of your code.
And typically, depending on the complexity of the project, you can have multiple repositories for your project.
Important, we will have something that we call their remote repository.
That is something that will be allocated in GitHub, GitLab, Bitbucket or whatever you want.
Again, I propose Bitbucket connect to Bitbucket, register an account and create your first repository there.
Additionally, apart from this remote repository, you will have a local repository that will be a local copy or something that is typically in the cloud.
You will you will download a copy of the remote repository something that we call clone.
Clone is copy.
Make a copy of something.
You we'll be working with this local repository making changes to the code.
Changes by changing the code, I compile the code in the code I verify that things are working correctly.
And once I'm happy with the result of something.
I can create something that we call commit.
For instance, I'm communicating with accelerometer sensor and I've been able to communicate with the sensor and identify the sensor.
And I built a very simple program with four functions.
I can make a commit a commit to my local repository saying something that.
this is my first example communicating with the sensor, for instance, okay?
Okay, once I'm happy with something that I've completed, locally, in my computer, I have the options to push or to publish that to the global repository or to the remote repository, okay, and make these available in the remote repository.
That is something that we call push, okay.
Imagine that two of you are working in the same project, you can have your own local repository and you are implementing the communication with the accelerometer.
And your colleague is developing the communication with a color sensor.
If you do the things correctly, you will do a clone to have a local copy, you will implement the color sensor, one of you, the other one, the accelerometer, when some of you make the commit will be saving the changes of the part.
And when the other is developing the color sensor will save the changes of that other part.
And finally, both developers can have the same code of the application working and tested.
Both of them know very well the evolution of the project.
Okay, so here we have clone and commit, clone to download the project locally, commit to put the changes locally, push to publish the change in the repository.
And here automatically arise one question.
Okay, what happened if I try to upload my color sensor version of the code and my colleague has previously uploaded their changes about the accelerometer.
Don't worry, because the tool is going to complain about.
you're trying to push a copy of something.
that you don't have the latest version, okay?
Both of you are trying to do the same thing okay.
Of course, you cannot do both things simultaneously.
So, the first one gaining the repository will do a push and automatically the other colleague.
when he tries to do the push.
your will see a mail message, that be careful you don't have the latest copy.
So please pull to obtain the last version.
This last version will be more or less merge together and after that you will upload the version with your specific changes about the color section for example, okay?
So, more or less this is the basic idea.
I'm explaining this like a very simple thing okay but this is something that we will see how to how to do it okay in the future okay.
So, the first use that you are going to to have of this git tool is a personal use okay.
So, in principle you are not going to have conflict or problem but as soon as we progress in the course, you, a couple will in will be working in parallel in the same problem okay.
So you will need to be very careful with that step and we will see how to solve solve the typical situation.
Are you understanding me?
Yep. Okay.
This is I think this is a good slide to represent the different steps that we have here.
So we are working with something that this is located in the remote, okay, place.
And typically, we are doing something that is okay.
I want to get a local copy doing doing the clone,and after that we can add local themes.
Okay, as soon as we implement the hit commit, or we execute the git commit, this information is stored stored in our local repository, making the push, we we will, we are doing that available in the remote repository.
Okay, if you want to have the latest version of the report, you need to implement the git pull.
And as soon as the system detects any kind of issue or problem, because you are modifying the same file, or there are any kind of conflict, we will work with something that we will discuss next week about the concept of Git merge and the checkout more additional functionalities that are available in this in the store.
Okay, so today is something related only to conference.
My proposal, please use GitHub, sorry, Bitbucket create there a repository, create first create an account to log into the account, create your first repository.
and please add Miguel ï¿½?ngel and myself, if you want, of course, to share these with with us to see what is your evolution or their progress with the things.
Okay, so what is the first step to install so in the in the Windows computer, you have already installed the git client for for the ubuntu operating system, you need to execute this, so you have the virtual machine available for you.
And the virtual machine in this moment does doesn't have the, the the git installed.
So if you want to install the git, you only, you only need to execute that command.
This is something that means you have super user rights APD installed git tools.
Okay, with that you install the commander, there are some graphical versions of the tools.
But in our first stage, I don't recommend the use of the graphical tools until you have a basic knowledge of the things that you are doing.
Okay, so forgot to use these graphical versions, I prefer that you use the code, okay.
And for example, if you want to clone a repository is something simple, because you open a terminal and you execute git clone.
And then address of the repository, typically, you'll need a log in and a password unless the repository is public.
And you can download the local copy to your computer.
So with that, the steps are very simple, we create an empty folder.
We implement or we execute the git clone, the repository already exists.
And using the command git add, I'm adding files to the local file to this to the repository.
With git commit, I boot, I boot the data changes in the local repository.
And finally, executing git push we are publishing or making available, the changes to the remote repository.
Great. So more or less, four, five commands, to do the basic or to implement the basic steps.
Okay, so my proposal very simple proposal to start playing with this, my recommendation is start playing with it.
Create Your Account when when you prefer the the place that you you want, create your first repository, put some environment variables that are mandatory, invite Miguel ï¿½?ngel and myself to use these.
Start playing with these basic commands,.
with stupid files only with simple test to see the evolution of the things that you are doing.
And play with Git add, git commit, git push, git pull and all these command to start understanding the idea.
And have a look to this.
Only as something that is very introductory and something to start playing with.
Don't worry about that.
Play with this and next week we can discuss about the concepts again.
Okay, because this is new, and probably the first time that you play with this is a little bit confusing or difficult to understand.
So I think we are on time.
So, we have, we have finished the presentations.
Do you have any big question, big problem or theme to discuss?
Everything is clear?
Okay, so One second.
So what's the purpose of this?
Okay this is a USB Wi Fi that will be used when you are working working here in the lab or at home.
and you have a virtual machine running Ubuntu, okay.
The idea is to connect to a Wi Fi using this.
Okay, so here in the lab we will have a specific Wi Fi access point with no connection to internet, because the only that we are going to do is here .
we are going to install here like a network sensor.
Okay, sensor network, no more than that, but no connection to the Internet.
The idea is that with this Wi Fi connection, you can there you have the option to connect to the Raspberry Pi, okay, of course, using the Wi Fi network provided by this Wi Fi router.
But again, with no access to internet.
In the Windows computer, the same computer that is running the Ubuntu virtual machine you have there the Ethernet connection and this Ethernet connection, of course, has access to the external world, okay?
And you can download things and follow all the things that you want to do okay.
So, take a picture of these, and take these into account and in a Moodle site you have different pictures with the suggested configurations that should be used at home okay.
But be careful with this because as soon as you connect to this Wi Fi that has no access to internet you cannot download software to the virtual machine, you cannot connect to any external place okay, you can only communicate with a Raspberry Pi.
So, what is the purpose of this cable?
This is a USB to serial line interface.
So, it's this.
And what's the purpose?
The first time that you connect the Raspberry Pi to the Wi Fi probably, you'll fail.
Because you have an incorrect identification SSID.
or the password is wrong or whatever problem you have.
So, using this interface using a serial line, you can connect to the Raspberry Pi using a terminal typically you put the program and you can verify that this Linux is working properly.
I made the phrases correctly configured.
Okay, so that's the purpose of this cable, okay: to connect the USB in my personal computer or in the lab computer to the Raspberry Pi okay?
This is the power supply.
Please use always this power supply.
I don't want to see the Raspberry Pi connected to your power adapter used to charge your mobile phone or connect the Raspberry Pi to the USB block available in the computer because you will have problems with the hardware okay and you can damage the hardware so please use always this power supply.
You have here the accelerometer in two weeks you will have the color sensor.
Okay, and you have the Raspberry Pi with a XX.
That's all. Questions?
Next week: homeworks install the Raspbian, ask about the questions that I raised before about this collection of questions with answers.
Okay, I will open a task in Moodle you will have to submit before next class, okay?
And please, I encourage you to have a look at the ideas of how to manage git, okay, to interact with the use of Github or BitBucket or the tool that you prefer to develop our first XX one additional thing: will always use the same place you are now sit on okay? Why? Why?
We have the virtual machines and we don't want that you turn on the virtual machines in all the computers because in that case we will be running out of space, okay, and I don't want to have problems with that.
In Moodle you have the virtual machine available to be downloaded, so if you connect to the Moodle site, you can download the virtual machine and you can play at home with a virtual machine.
Okay, this is actually the same file that you have locally, okay, but please use always the same position, okay?
And one option is that as you have to generate couples to work together probably, you can follow this organization but if you want to organize the themes think about it at the beginning of the next class we can reorganize the couple okay?
Everything is clear?
Okay thank you very much!
See youSession 4This is a tool to help us to develop.
Or control the development of our software application.
OK it's a very interesting tool.
To track the evolution of the code and the other day we were doing we were explaining different simple things about the basic commands about the basic functionalities that we have to manage.
The basic functions of git OKSo the idea today is to start givingAdditional information thinking on a collaborative use of thisOK what's the goal of thisIn principle you are going to work in couples.
And the idea is that you are going to develop a project.
In couples.
OKSo the idea is that in principle you're going to work together.
On the same projectand you are going to add removeAnd make different changes in the codeUsing git okay?
So that's the idea of thisI think it's very interesting to Start learning this nowBecause probably at least the students of this school have not experienced using this and it's very complicated if not impossible to control the evolution of the code with folders and versions of the same file it's impossible to maintain and impossible to control it's impossible to fix errors and to give you some feedback.
OK so the proposal is all of your projects should be managed using git OK for me it's not an issue if you if you want to use instead of Bitbucket GitHub or whatever git in the cloud that you want to use no problem with that the only point is that if you want to share with Miguel Angel and myself the project in order to track the evolution of your code OK?
OK so what are the things that we know until now?
In principle the other day we were talking about how to initialize our repository.
OK how to download a copy of that repositorything that we didn't define as the clone operation how to do local changes in my files and once that I consider that that code is ready for something.
I'm doing local saves or local copies of that code and I perform commit to my local repository and after that I send my local copy of the repository out to the GitHub GitLab or Bitbucket or the application that you want to use using push OK?
So basically we create a new report or are we copy a report that is available somewhere and do a copy of that I change the source code locally and as soon as I want to save that change locally I use the git commit command once that I've already completed that command I publish the changes in the cloud version or the remote repository using push OK?
and if we want to have the last version of the codethat's available in the remote repository we used the pull command okay?
So let me show you this in a very simple way okay?
OK I'm going to log in on BitbucketSo I have here this report this report I created this morning it's a very simple report for doing the test OK and it's available in Bitbucket the first operation that I'm going to perform is to execute a clone of the report.
Si I go here, and in clone I get a command that is ILet me one second to create here a folder RPiI'm going to open here a console and I'm going to execute the command git clone okay.
With that I am accessing my report and I am performing a local copy of the remote repository okay?
So now I have here a folder with the code with different files okay?
In principle with one file sorry I use an editor OK I can see the content of the file.
OK it's a very very simple file.
OK So what happens if I perform here some modification?
we are going to do a very very simple modification for instance creating a new file and we are going to assign a value I'm going to save the changes.
OK and if I execute git status sorry git status you can see here that there is a file that is already modified OK so we are going to do execute the at command that means that aren't changes to the local repository the file is added if I check again the status the file is already saved in the local stageor or the local stash copy of the repository okay?
Once I decide that this file is ready to be shared with my colleague is ready to do something with it I'm going to execute a commit command and in a message try to put always a meaningful (tag) we are going to add that file to my local repository and once we have that what we are going to do is to execute a push of that file in the remote repository okay?
So now if I navigate directly to the report and I update the report.
I will see here in the left part the commit and I have here the last changes that we have done in our file okay?
And additionally you can track the changes that have been doing this morning which I did the initial commit and modification and some things that I've been doing okay?
So if you use this the advantage you will have is that you can track the evolution of your code.
OK So, the basicsFrom the report create local changes add local changesPerform a commit of these changes to the local repository with a message push to publish that content in the remote repository okay?
So what happens if my colleague is working with a report and wants to have a copy of the last version of the report?
In that case we have the command pull.
OK to bring to my computer a remote copy to the local repository okay?
So this means that if you are working together on the same project you need to be in phase to avoid problems as we will see later how to solve OK this is the basic things that we are going to use so my expectation our expectation in the first part of the course or at least you manage these commands and then to keep a copy of your project and to follow to track the project okay?
And with this we can avoid the typical things that he was working yesterday today he's not working I don't know why I have the things in this other folder this kind of things should be avoided using this strategy of using git OK?
And this is the basic view but of course this is yeah this is the getting started of git but git has more has additional functionalities that are very very interesting and the first one is the concept of a branch what means that that means that when we are developing software in one specific point I can say to my colleague please implement this specific functionality read this register from the accelerometer.
OK my colleague instead of working with the main or the principal or the master branch of the code is going to create another branch a branch is really like a copy that is a pointer to the last version of the code and we are going to assign a specific name to that branch for instance typically devel feature and a name whatever you can imagine but something with some something that is important for you don't put a useless name because it's quite difficult to track the thing okay?
So this means that if you create a branch  you switch to that branch and you perform the modifications in that branch once that you check that that part of the code is working your colleague can bring that changes to their branch OK?
And this is something that we typically call merge merge is like we are mixing the things okay?
In principle if you are developing one thing and your colleague is developing another thing when you perform the merge typically there are no problems or issues and the point here is that two developers are doing the same thing in that case we have the typical thing that we call conflicts.
OK this is the thing that you should avoid so the idea is that at the end of the course when you are developing the main project of the course.
You use this idea of branches to more or less organise the development of the codeAre you understanding me yeah?
OK can you hear me there at the end yeah?
What is a branch?
So a branch is a line of development it's quite easy to create a branch if we move to the Bitbucket we can go to this place branch and we can create here a branch you see for instance taking as input the main branch I can create a branch that we call devel.
OK and at this point we have two branches of the code as soon as we move to the local repo and we execute the command git fetch which means something to search for changes in the remote repo this is going to discover that there is a new branch that is called devel okay?
And we can change to that branch you see in the command you check out and the name of the branch OK and if I execute this here always git status we can see always here in this part the name of the branch where we are okay?
So now if we perform here modifications in the file okay and my colleague is adding a new function okay?
I can save that to the local stash I can create a commit with a new function OK and I can push this to the remote repository to the branch devel okay?
So now if we move to here to my remote repo here we are in the main sorryif we have a look at the content of the file.
I don't have here the changes because the changes are in the branch that we have called colleague devel, okay?
and it's quite simple to manage okayif you do the things in an intelligent way okay that is a branch OK what are the typical names of the branches?
Typically "main" so master was the old definition but with these new times that we are avoiding words that can be or can offend to other guys or other people master is never used any more and we are using main OK?
devel typically is where we are developing thingsand main is always like the release version of the code the final product that we are going to have OK so with this organization you can create an intelligent evolution of the code ways to create branches and to change from one branch to another using the command git check out with that you change the branch that you are using.
OK and with git status git status you can verify in which branch you are for instance here executing git status we can see that we are in the master branch OK that's the old definition now it's the main branch that means that here we have a new file and the file that we have deleted okay?
and files that are in traffic?
these are files that are not controlled by Github.
what is the mechanism to use git branches?
So the procedure is we change from a specific branch with the command check out OK we put the last changes of that branch with pull we are doing a copy of the remote repo so a local repo OK with that we are discovering the last changes.
OK and we are doing that changes locally okay?
And finally if we want to move some specific content of one branch to another so this means we want to move the changes that we have in the devel branch to the master branch or to the main branch what we execute is this command git merge okay?
And when you are merging the problem could be that you have conflicts.
OK because two developers are modifying the same function or even two developers are changing the same line of code that is something that you should avoid okay?
In the next slide we have you have a description of the problem.
OK please have a look to that and basically what happens is the following when you execute the merge if everything is correct because there is no conflict you will see something like this you are mixing the code no problem what happens if there is an error?
If it's impossible to merge?
In that case you see a message saying you that there are conflicts and you need to solve that conflict OK so that means that you have to compare files and select which is the appropriate code which you want finally maintain.
OK imagine that he defines the variable A and you define the variable B you put that in the same line of code and the problem is you have to decide if you want variable A or variable B it's as simple as that typical tools to resolve conflicts I recommend that when you are working in Linux you use Mel Mel is a very interesting tool to compare source files.
OK you can see on the screen the source files and you can compare line by line the content of the file and you can move things from one file to another.
On the contrary.
OK it's quite useful and in GitHub if you have the mel installed you can invoke mel using this merge tool when you do that typically you see something like this a graphical tool.
with the different files in order to select what is the final code that you want to have and you can move things from one file to another okay?
This is the file in a specific branch that is going to be merged this is the resulting file this is the current content that we have in the local repository and moving things we can select finally in this file what is the final content.
OK the real thing for you is that when you are doing this unless that you are doing the same modifications we never have conflicts again unless that you are changing the same things okay?
Please have a look to the slides to understand this correctly I recommend you this address OK to download these graphical representations of the meaning of the different commands.
that we are using in GitHub sorry in git to manage the use of the repos.
OK it is interesting to understand graphically the things that you are doing.
How to discover remote changes is something that I have already executed on my computer with git merge how to merge.
have a look to that OK and the first time that you have an issue tell me and I will help you to understand how to solve the conflicts and these kind of things, okay?
Useful things please use commit with meaningful messages.
don't put version one version two version three that has no sense this is a version that is reading the registers and is working or is not working and it is not working because there is this problem something that is meaningful for the reviewer or your classmate or for you OK so try to organize your development in different characteristics or features.
OK for instance if we have if we have to develop the accelerometer and we want to do something with the Y axis acceleration you can perform one push and for that this can be a branch you can create another branch to develop something to read the speed of variation of a specific axis so whatever you can imagine please organize that in different branches to see how you are evoluting the code try to push in the branches in the devel branch code that is already compiling linked and typically working.
OK and with that you will avoid problems in the future and push to master only a stable version.
this will be what Miguel Ãngel and myself will be evaluating and doing the assessment in the different parts of the code, okay?
So more or less different branches to develop things when you are sure that that specific thing is working move to devel and once you consider that all your software is ready move to the master or the main branch, okay?
This is a quite quick guide with the commands clone checkout merge pull push you need to be familiar with this in the first part of the course.
OK basic development and if you are doing things typically you are using these commands and the only problem can be here when you are trying to solve conflicts.
OK so in that case if it's your first time solving conflicts call us and we will try to help you to understand the issue I'm to solve the things.
OK because probably if you don't have previous experience using this or the first time it's a little bit difficult to master questions are you understanding me yes sure sure we will see later.
OK no questions try to use it OK because it is a typical skill that is very requested by companies.
